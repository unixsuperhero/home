#!/usr/bin/env ruby

require "pry"
require "fileutils"
require "yaml"

class Hiiro
  def self.init(*args, &block)
    new($0, *args).tap do |hiiro|
      hiiro.add_subcmd(:pin) do |*args|
        case args
        in [] then hiiro.pins.pins.each {|k,v| puts "#{k} => #{v.inspect}" }
        in ['all'] then hiiro.pins.pins.each {|k,v| puts "#{k} => #{v.inspect}" }
        in ['get', name] then puts hiiro.pins.get(name)
        in [name] then puts hiiro.pins.get(name)
        in ['rm', name] then puts hiiro.pins.remove_and_save(name)
        in ['remove', name] then puts hiiro.pins.remove_and_save(name)
        in ['set', name, value] then hiiro.pins.set_and_save(name, value)
        in [name, value] then hiiro.pins.set_and_save(name, value)
        else
          puts "No matching pin subcommand for #{args.inspect}"
        end
      end

      block.call(hiiro) if block
    end
  end

  attr_reader :bin, :bin_name, :all_args
  attr_reader :subcmd, :args

  def initialize(bin, *args)
    @bin = bin
    @bin_name = File.basename(bin)
    @all_args = args
    @subcmd, *@args = args # normally i would never do this
  end

  def run
    if runner
      result = runner.run(*args)

      handle_result(result)
    else
      help
    end
    
    exit 1
  rescue => e
    puts "ERROR: #{e.message}"
    puts e.backtrace
    exit 1
  end

  def config_dir
    File.join(Dir.home, '.config/hiiro').tap do |config_path|
      FileUtils.mkdir_p(config_path) unless Dir.exist?(config_path)
    end
  end

  def pins = @pins ||= Pin.new(self)

  def handle_result(result)
    exit 0 if result.nil? || result

    exit 1
  end

  def runner
    @runner ||= runners.runner
  end

  def runners
    @runners ||= Runners.new(bin_name, subcmd)
  end

  def add_subcommand(name, &block)
    runners.add_subcommand(name, block)
  end
  alias add_subcmd add_subcommand

  def full_name
    runner&.full_name || [bin_name, subcmd].join(?-)
  end

  def subcommand_names
    runners.subcommand_names
  end

  def help
    puts "Subcommand #{subcmd.inspect} not found!"
    puts
    puts "Possible subcommands:"

    subcommand_names.each { |n| puts "  #{n}" }

    binding.pry
  end

  class Runners
    attr_reader :bin_name, :subcmd

    def initialize(bin_name, subcmd)
      @bin_name = bin_name
      @subcmd = subcmd
    end

    def runner
      matching_bin || matching_subcommand
    end

    def partial
      [bin_name, subcmd].join(?-)
    end

    def subcommand_names
      [*all_bins, *subcommands].map(&:subcommand_name)
    end

    def paths
      @paths ||= ENV['PATH'].split(?:).uniq
    end

    def bins
      @bins ||= lambda {
        pattern = format('{%s}/%s*', paths.join(?,), partial)

        Dir.glob(pattern).map { |path| Bin.new(bin_name, path) }
      }.call
    end

    def all_bins
      pattern = format('{%s}/%s-*', paths.join(?,), bin_name)

      Dir.glob(pattern).map { |path| Bin.new(bin_name, path) }
    end

    def subcommands
      @subcommands ||= []
    end

    def add_subcommand(name, handler)
      subcommands << Subcommand.new(bin_name, name, handler)
    end

    # normally i would call this: bin ...but that's already an attr
    def matching_bin
      return exact_bin if exact_bin

      matching_bins.first if matching_bins.count == 1
    end

    def exact_bin
      @exact_bin ||= bins.find { |b| b.exact_match?(partial) }
    end

    def matching_bins
      @matching_bins ||= all_matching_bins.reject { |b|
        all_matching_bins.any? { |ob|
          ob != b && b.name.start_with?(ob.name + ?-)
        }
      }
    end

    def all_matching_bins
      @all_matching_bins ||= bins.select { |b| b.match?(partial) }
    end

    # normally i would call this: subcommand ...but that's already an attr
    # the reason is: i want the simplest/most direct word to be the thing i really want
    # i don't want the matched subcommand to be something like: Hiiro#best_matching_subcommand
    # i want it to be Hiiro#subcommand
    # i actually might change @subcommand to something like @partial_subcommand
    # so that i can rename this to subcommand
    def matching_subcommand
      return exact_subcommand if exact_subcommand

      return matching_subcommands.first if matching_subcommands.count == 1
    end

    def exact_subcommand
      @exact_subcommand ||= subcommands.find { |b| b.exact_match?(subcmd) }
    end

    def matching_subcommands
      @matching_subcommands ||= subcommands.select { |b| b.match?(subcmd) }
    end

    # if i wanted to reduce the lines of code, i could combine Bin/Subcommand
    # but i would have to introduce a new attr and arg to the constructor: @type
    # then for methods like #full_name and #run i would have to branch off of
    # @type
    class Bin
      attr_reader :bin_name, :path, :name
      alias full_name name

      def initialize(bin_name, path)
        @bin_name = bin_name
        @path = path
        @name = File.basename(path)
      end

      def run(*args)
        system(path, *args)
      end

      def exact_match?(partial)
        name == partial
      end

      def match?(partial)
        name.start_with?(partial)
      end
      
      def subcommand_name
        name.sub("#{bin_name}-", '')
      end
    end

    class Subcommand
      attr_reader :bin_name, :name, :handler
      alias subcommand_name name

      def initialize(bin_name, name, handler)
        @bin_name = bin_name
        @name = name.to_s
        @handler = handler
      end

      def run(*args)
        handler.call(*args)
      end

      def exact_match?(subcmd)
        name == subcmd.to_s
      end

      def match?(subcmd)
        name.start_with?(subcmd.to_s)
      end

      def full_name
        [bin_name, name].join(?-)
      end
    end
  end

  class Pin
    attr_reader :hiiro

    def initialize(hiiro) = @hiiro = hiiro

    def get(name)
      pins[find(name)]
    end

    def set(name, value)
      pins[name.to_s] = value
    end

    def set_and_save(name, value)
      set(name, value)
      save_pins
      value
    end

    def find(partial)
      pins.keys.map(&:to_s).find do |pin_name|
        pin_name.start_with?(partial)
      end
    end

    def find_all(partial)
      pins.keys.map(&:to_s).select do |pin_name|
        pin_name.start_with?(partial)
      end
    end

    def remove(name)
      all_matches = find_all(name)

      if all_matches.count > 1
        puts "Unable to remove pin.  Multiple matches: #{all_matches.inspect}"
        return
      end

      pin_name = all_matches.first

      pins.delete(pin_name.to_s)
    end

    def remove_and_save(name)
      remove(name)
      save_pins
      pins
    end

    def pin_filename = hiiro.bin_name
    def pin_dir = File.join(hiiro.config_dir, 'pins').tap {|dir| FileUtils.mkdir_p(dir) }
    def pin_file = File.join(pin_dir, pin_filename)
    def pins
      return @pins if @pins

      unless File.exist?(pin_file)
        File.write(pin_file, YAML.dump({}, stringify_names: true))
      end

      @pins = YAML.safe_load_file(pin_file)
    end

    def save_pins(pins = nil)
      pins = pins || @pins || {}

      File.write(pin_file, YAML.dump(pins, stringify_names: true))
    end

    def pins!
      @pins = nil
      pins
    end
  end
end

# only run the runner if being called from the commandline
if __FILE__ == $0
  hiiro = Hiiro.init(*ARGV)

  hiiro.add_subcommand(:good) { |*args|
    puts "inside :good #{args.inspect}"
  }

  hiiro.run
end

