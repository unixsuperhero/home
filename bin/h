#!/usr/bin/env ruby

require "pry"
require "fileutils"
require "yaml"

class Hiiro
  def self.init(*args, plugins: [], logging: false, **values, &block)
    new($0, *args, logging: logging, **values).tap do |hiiro|
      hiiro.load_plugins(*plugins)

      hiiro.add_subcmd(:edit, **values) { |*args|
        system(ENV['EDITOR'] || 'nvim', hiiro.bin)
      }

      hiiro.add_subcmd(:ppath) { |*args, **v|
        print File.join(`git rev-parse --show-toplevel`.strip, v[:rdir])
      }

      hiiro.add_subcmd(:rpath) { |*args, **v|
        print v[:rdir]
      }

      hiiro.add_subcmd(:path) { |*args, **v|
        print v[:dir]
      }

      block.call(hiiro) if block
    end
  end

  def self.load_env
    Config.plugin_files.each do |plugin_file|
      require plugin_file
    end
  end

  attr_reader :bin, :bin_name, :all_args
  attr_reader :subcmd, :args
  attr_reader :loaded_plugins
  attr_reader :logging
  attr_reader :global_values

  def initialize(bin, *args, logging: false, **values)
    @bin = bin
    @bin_name = File.basename(bin)
    @all_args = args
    @subcmd, *@args = args # normally i would never do this
    @loaded_plugins = []
    @logging = logging
    @global_values = values
  end

  def run
    result = runner.run(*args)

    handle_result(result)
    
    exit 1
  rescue => e
    puts "ERROR: #{e.message}"
    puts e.backtrace
    exit 1
  end

  def handle_result(result)
    exit 0 if result.nil? || result

    exit 1
  end

  def runnable?
    runner
  end

  def runner
    runners.runner || runners.default_subcommand
  end

  def runners
    @runners ||= Runners.new(self)
  end

  def add_default(**values, &handler)
    runners.add_subcommand(:DEFAULT, handler, **global_values, **values)
  end

  def add_subcommand(name, **values, &handler)
    runners.add_subcommand(name, handler, **global_values, **values)
  end
  alias add_subcmd add_subcommand

  def full_name
    runner&.full_name || [bin_name, subcmd].join(?-)
  end

  def subcommand_names
    runners.subcommand_names
  end

  def pins = @pins ||= Pin.new(self)

  def load_plugins(*plugins)
    plugins.flatten.each { |plugin| load_plugin(plugin) }
  end

  def load_plugin(plugin_const)
    return if @loaded_plugins.include?(plugin_const)

    plugin_const.load(self)
    @loaded_plugins.push(plugin_const)
  end

  def help
    subcmd_msg = "Subcommand required!"
    subcmd_msg = "Subcommand #{subcmd.inspect} not found!" if subcmd

    puts subcmd_msg
    puts ""
    puts "Possible subcommands:"

    subcommand_names.reverse.each { |n| puts "  #{n}" }
  end

  def log(message)
    return unless logging

    puts "[Hiiro: #{bin_name} #{(runner&.subcommand_name || subcmd).inspect}]: #{message}"
  end

  def parsed_args
    i = Args.new(*args)
  end

  class Config
    class << self
      def plugin_files
        Dir.glob(File.join(plugin_dir, '*'))
      end

      def plugin_dir
        config_dir('plugins')
      end

      def config_dir(subdir=nil)
        File.join(Dir.home, '.config/hiiro', *[subdir].compact).tap do |config_path|
          FileUtils.mkdir_p(config_path) unless Dir.exist?(config_path)
        end
      end
    end
  end

  class Runners
    attr_reader :hiiro, :bin_name, :subcmd, :subcommands

    def initialize(hiiro)
      @hiiro = hiiro
      @bin_name = hiiro.bin_name
      @subcmd = hiiro.subcmd
      @subcommands = {}
    end

    def runner
      return default_subcommand if subcmd.to_s == ''

      matching_bin || matching_subcommand
    end

    def default_subcommand
      Subcommand.new(bin_name, :default, lambda { hiiro.help; false })
    end

    def partial
      [bin_name, subcmd].join(?-)
    end

    def subcommand_names
      [*all_bins, *subcommands.values].map(&:subcommand_name)
    end

    def paths
      @paths ||= ENV['PATH'].split(?:).uniq
    end

    def bins
      pattern = format('{%s}/%s*', paths.join(?,), partial)

      Dir.glob(pattern).map { |path| Bin.new(bin_name, path) }
    end

    def all_bins
      pattern = format('{%s}/%s-*', paths.join(?,), bin_name)

      Dir.glob(pattern).map { |path| Bin.new(bin_name, path) }
    end

    def add_subcommand(name, handler, **values)
      @subcommands[name] = Subcommand.new(bin_name, name, handler, values)
    end

    # normally i would call this: bin ...but that's already an attr
    def matching_bin
      return exact_bin if exact_bin

      matching_bins.first if matching_bins.count == 1
    end

    def exact_bin
      bins.find { |b| b.exact_match?(partial) }
    end

    def matching_bins
      all_matching_bins.reject { |b|
        all_matching_bins.any? { |ob|
          ob != b && b.name.start_with?(ob.name + ?-)
        }
      }
    end

    def all_matching_bins
      bins.select { |b| b.match?(partial) }
    end

    # normally i would call this: subcommand ...but that's already an attr
    # the reason is: i want the simplest/most direct word to be the thing i really want
    # i don't want the matched subcommand to be something like: Hiiro#best_matching_subcommand
    # i want it to be Hiiro#subcommand
    # i actually might change @subcommand to something like @partial_subcommand
    # so that i can rename this to subcommand
    def matching_subcommand
      return if subcmd.nil?
      return exact_subcommand if exact_subcommand

      if matching_subcommands.count > 1
        hiiro.log("Multiple matching subcommands:")
        matching_subcommands.each { |m| hiiro.log("  #{m.name}") }
      end

      return matching_subcommands.first
    end

    def exact_subcommand
      subcommands.values.find { |v| v.exact_match?(subcmd) }
    end

    def matching_subcommands
      subcommands.values.select { |v| v.match?(subcmd) }
    end

    # if i wanted to reduce the lines of code, i could combine Bin/Subcommand
    # but i would have to introduce a new attr and arg to the constructor: @type
    # then for methods like #full_name and #run i would have to branch off of
    # @type
    class Bin
      attr_reader :bin_name, :path, :name
      alias full_name name

      def initialize(bin_name, path)
        @bin_name = bin_name
        @path = path
        @name = File.basename(path)
      end

      def run(*args)
        system(path, *args)
      end

      def exact_match?(partial)
        name == partial
      end

      def match?(partial)
        name.start_with?(partial)
      end
      
      def subcommand_name
        name.sub("#{bin_name}-", '')
      end
    end

    class Subcommand
      attr_reader :bin_name, :name, :handler, :values
      alias subcommand_name name

      def initialize(bin_name, name, handler, values={})
        @bin_name = bin_name
        @name = name.to_s
        @handler = handler
        @values = values || {}
      end

      def run(*args)
        handler.call(*args, **values)
      end

      def exact_match?(subcmd)
        name == subcmd.to_s
      end

      def match?(subcmd)
        name.start_with?(subcmd.to_s)
      end

      def full_name
        [bin_name, name].join(?-)
      end
    end
  end

  class Args
    attr_reader :raw_args

    def initialize(*raw_args)
      @raw_args = raw_args
    end

    def flags
      @flags ||= proc {
        raw_args.select { |arg|
          arg.match?(/^-[^-]/)
        }.flat_map { |arg|
          arg.sub(/^-/, '').chars
        }
      }.call
    end

    def flag?(flag)
      flags.include?(flag)
    end

    def flag_value(flag)
      found_flag = false
      raw_args.each do |arg|
        if found_flag
          return arg
        end

        if arg.match?(/^-\w*#{flag}/)
          found_flag = true
        end
      end

      nil
    end

    def values
      raw_args.reject do |arg|
        arg.match?(/^-/)
      end
    end
  end
end

Hiiro.load_env


# only run the runner if being called from the commandline
if __FILE__ == $0
  hiiro = Hiiro.init(*ARGV, plugins: [Tmux, Pins, Project, Task], cwd: Dir.pwd)

  hiiro.add_subcommand(:good) { |*args|
    puts "inside :good #{args.inspect}"
  }

  hiiro.add_subcommand(:test) { |*args, **v|
    puts 'test successful'
  }

  hiiro.run
end

