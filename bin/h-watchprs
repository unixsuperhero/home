#!/usr/bin/env ruby

require 'pry'
require 'json'
require 'digest'

SLEEP_TIME = ENV.fetch('sleep_for', 60)
prs = {}
approvals = {}
first_run = true

last_prs = {}
last_json_md5 = nil

class Pr
  attr_reader :data

  def self.prs_from_json(json)
    JSON.parse(json).each_with_object({}) do |pr, h|
      o = new(pr)

      h[o.number] = o
    end
  end

  def initialize(data)
    @data = data
  end

  def author = data.dig(*%w[author login])
  def branch = data["headRefName"]
  def number = data["number"]

  def is_draft = data["isDraft"]
  def merge_state_status = data["mergeStateStatus"]
  def mergeable = data["mergeable"]
  def review_decision = data["reviewDecision"]
  def state = data["state"]
  def title = data["title"]
  def url = data["url"]
  def comments = data["comments"]
  def comment_count = comments.count

  def to_h
    {
      number:,
      branch:,
      author:,
      is_draft:,
      merge_state_status:,
      mergeable:,
      review_decision:,
      state:,
      title:,
      url:,
      comment_count:,
    }
  end

  def diff(old_pr)
    new_values = to_h
    old_values = old_pr.to_h

    diff = new_values.each_with_object({}) do |(k, v), h|
      next if old_values[k] == v

      h[k] = [old_values[k], v]
    end
  end
end

loop do
  stdout = `gh pr status`

  md5 = Digest::MD5.hexdigest(stdout)

  first_run = false

  if stdout.match?(/something went wrong/i)
    sleep SLEEP_TIME
    next
  end

  collecting = false
  current_pr = nil
  new_statuses = {}
  new_approvals = {}
  stdout.lines(chomp: true).map do |line|
    collecting = true if line.match?(/created by you/i)
    next unless collecting

    if num = line[/[#]\d+/]
      current_pr = num.sub(?#, '')
      next
    end

    if current_pr && line.match?(/checks (pending|passing|failing)/i)
      new_status = line[/pending|passing|failing/]

      old_approval_count = approvals.fetch(current_pr, 0)

      if line.match?(/✓ (\d\d*) Approved/)
        partial = line[/✓ (\d\d*) Approved/]
        approval_count = partial[/\d\d*/]
        new_approvals[current_pr] = approval_count
      end

      approvals[current_pr]
      new_statuses[current_pr] = new_status
      current_pr = nil
    end

    break if line.match?(/^\s*$/)
  end

  status_changed = new_statuses.any?{ |pr,new_status| prs[pr] != new_status }
  approvals_changed = new_approvals.any?{|pr,new_approval_count| approvals[pr] != new_approval_count }

  if status_changed || approvals_changed
    puts
  end

  new_approvals.each do |current_pr, new_approval|
    if approvals.has_key?(current_pr)
      if approvals[current_pr] != new_approval
        system('say', 'pr', 'has', new_approval, 'approvals')
        puts format('%7s (approvals: %s): https://github.com/instacart/carrot/pull/%s', current_pr, new_approval, current_pr)
      end
    else
      system('say', 'pr', 'has', new_approval, 'approvals')
      puts format('%7s (approvals: %s): https://github.com/instacart/carrot/pull/%s', current_pr, new_approval, current_pr)
    end
  end

  new_statuses.each do |current_pr, new_status|
    if prs.key?(current_pr) && prs[current_pr] != new_status
      system('say', 'pr', 'is', new_status)

      if new_status[/passing/]
        system('say', 'publishing pr')
        system('gh', 'pr', 'ready', current_pr)
        system('gh', 'pr', 'view', '-w', current_pr)
      end

      puts format('%7s (%s): https://github.com/instacart/carrot/pull/%s', current_pr, new_status, current_pr)
    end
  end

  prs = new_statuses
  approvals = new_approvals

  sleep SLEEP_TIME
end
